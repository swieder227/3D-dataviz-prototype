<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>demo Three.js app</title>
		<style>
			body { margin: 0; overflow: hidden; }
      #container, #ui { position: absolute; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
    <div id="container"></div>
    <div id="ui">
      <button onclick="setCameraPosition()">Sup</button>
    </div>
		<script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
		<script>
      // Setup scene, camera, renders
      var scene = new THREE.Scene();
      scene.background = new THREE.Color( 0xffffff );

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.querySelector('#container').appendChild( renderer.domElement );

      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      var controls = new THREE.OrbitControls( camera, renderer.domElement );

      var axis_helper = new THREE.AxisHelper( 5 );
      axis_helper.position.y = 10;
      scene.add(axis_helper);

      // setup cam
      camera.position.z = -28;
      camera.position.x = 55;
      camera.position.y = 55;

      function createGrid(options){
        let config = options || {
          height: 50,
          width: 50,
          linesHeight: 50,
          linesWidth: 10,
          color: 0xDD006C
        }

        let material = new THREE.LineBasicMaterial({
          color: config.color,
          opacity: 0.2
        });

        let grid_object = new THREE.Object3D(),
            grid_geo = new THREE.Geometry(),
            stepw = 2 * config.width / config.linesWidth,
            steph = 2 * config.height / config.linesHeight;

        //width
    		for ( var i = - config.width; i <= config.width; i += stepw ) {
    				grid_geo.vertices.push( new THREE.Vector3( -config.height, i, 0 ) );
    				grid_geo.vertices.push( new THREE.Vector3( config.height, i, 0 ) );

    		}
    		//height
    		for ( var i = - config.height; i <= config.height; i += steph ) {
    				grid_geo.vertices.push( new THREE.Vector3( i, -config.width, 0 ) );
    				grid_geo.vertices.push( new THREE.Vector3( i, config.width, 0 ) );
    		}

        var line = new THREE.LineSegments(grid_geo, material, THREE.LinePieces);
        grid_object.add(line);

        return grid_object;
      }

      let grid_dimensions = {
        width: 50,
        height: 15,
        depth: 20
      }

      let grid_object = new THREE.Object3D();

      let grid_xy = createGrid({
        width: grid_dimensions.height,
        height: grid_dimensions.width,
        linesHeight: 10,
        linesWidth: 10,
        color: 0x0000FF
      });
      grid_xy.position.z = grid_dimensions.depth;

      let grid_xz = createGrid({
        width: grid_dimensions.depth,
        height: grid_dimensions.width,
        linesHeight: 10,
        linesWidth: 10,
        color: 0xFF0000
      });
      grid_xz.rotateX(Math.PI / 2);
      grid_xz.position.y = -1 * grid_dimensions.height;

      let grid_yz = createGrid({
        width: grid_dimensions.height,
        height: grid_dimensions.depth,
        linesHeight: 10,
        linesWidth: 10,
        color: 0x00FF00
      });
      grid_yz.position.x = -1 * grid_dimensions.width;
      grid_yz.rotateY(Math.PI / 2);

      grid_object.add( grid_xy ).add( grid_xz ).add( grid_yz );
      scene.add( grid_object );


      function animate(){
        requestAnimationFrame( animate );
        // updateCamera();
        controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true

        render();
      }


      // render loop to re-draw frame 60 times per second
      function render() {
      	renderer.render( scene, camera );
      }

      animate();

		</script>
	</body>
</html>
